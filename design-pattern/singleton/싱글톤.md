# 싱글톤

# 싱글톤 패턴 정의

객체 생성에 관한 디자인 패턴이다. `단 하나의 객체를 생성하기 위한 패턴`이다. DB Connection Pool처럼 객체 생성 비용이 큰 경우에 유용하다.


# 싱글톤 패턴 구현 방법

`getInstance()` 메서드를 통해 유일한 인스턴스를 제공해야한다. 

## 1. 매우 간단하게 구현한 싱글톤(Lazy Initialization)

아래는 싱글톤 패턴을 정말 단순하게 구현한 방법이다. INSTANCE가 null인 경우에만 객체를 생성시키고 그 외에는 생성되어 있는 INSTANCE를 반환하는 형태이다.

이 코드는 동시에 여러 스레드에서 getInstance()를 호출하는 경우에는 유효하지 않다. 동시에 getInstance()를 호출한다면 INSTANCE가 null인경우에 동시에 만족하고 객체가 N개 생성되는 문제가 발생한다.  따라서 `단 하나의 객체를 생성하기 위한 패턴이라는 조건`을 지키지 못한다.
```java
class Singleton {

	private static Singleton INSTANCE;

    private Singleton() {};

    public static Singleton getInstance() {
		if(INSTANCE == null) {

		}
		return INSTANCE;
	}
}


```



### 2. Eager Initialization

static변수로 Singleton을 미리 생성해두는 방식으로 구현했다. static final이므로 멀티 스레드 환경에서도 스레드세이프를 보장한다. 하지만, 객체를 사용하기도 전에 미리 메모리에 올리는 방식이므로 객체의 크기가 크다면 메모리 용량을 미리 잡아먹는 문제가 있다.
```java
class Singleton {

	private static final Singleton INSTANCE = new Singleton();

    private Singleton() {};

    public static Singleton getInstance() {
		return INSTANCE;
	}
}

```



## 3. Thread Safe한 Lazy Initialization 방식

1번방식에서 메서드를 동기화시켜서 한번에 단 한개의 스레드만 접근가능하도록 해서 단 1개의 객체가 생성됨을 보장하는 방식이다. 스레드세이프하지만 synchronized로 인해서 성능저하가 발생한다.

```java

class Singleton {

	private static Singleton INSTANCE;

    private Singleton() {};

    public static synchronized Singleton getInstance() {
		if(INSTANCE == null) {

		}
		return INSTANCE;
	}
}


```



## 4. Double Checked Lock방식

thread safe한 lazy initializatioin방식은 매번 synchronized가 붙어있는 getInstance()를 호출하기때문에 성능이 좋지 않다. 그래서 최초 초기화에서만 synchronized를 적용하고 이미 만들어진 인스턴스를 반환할때는 synchronized를 사용하지 않도록 하는 방식이다.

구현해보면 이런 형태의 코드인데, 여기서 `if(INSTANCE == null)`부분에서 동시성 문제가 발생한다. 

```java
class Singleton {

	private static Singleton INSTANCE;

    private Singleton() {};

    public static Singleton getInstance() {
		if(INSTANCE == null) { //1
			synchronized(Singleton.class) {//2
				if(INSTANCE == null) { //3
					INSTANCE = new Singleton(); //4
				}
			}
		}
		return INSTANCE; //5
	}
}

```


`INSTANCE = new Singleton()` 은 아래와 같은 형태로 진행되는데

1. 객체를 할당할 메모리 공간 확보
2. 객체 초기화
3. 변수에 메모리 공간 연결

jvm에 의해서 최적화 과정을 거치면서 2번과 3번의 순서가 변경되는 경우가 있다고 한다.

만약 스레드1이  변수에 메모리 공간 연결까지 끝내고 객체를 초기화 하기 전인데 스레드2가 getInstance()를 호출하면 `if(INSTANCE == null)`코드에 도달했다고 가정하면 스레드2의 getInstance()결과값은 null을 받아서 문제가 발생한다.

이를 해결하기 위해서는 INSTANCE가 가시성을 보장하도록 volatile키워드를 붙여주면 해결할 수 있다.
```java

class Singleton {

	private static volatile Singleton INSTANCE;

    private Singleton() {};

    public static Singleton getInstance() {
		if(INSTANCE == null) { //1
			synchronized(Singleton.class) {//2
				if(INSTANCE == null) { //3
					INSTANCE = new Singleton(); //4
				}
			}
		}
		return INSTANCE; //5
	}
}


```